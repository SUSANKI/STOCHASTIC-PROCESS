---
title: "COPULA"
author: "NGUYEN NGOC PHUNG"
date: "12/26/2020"
output: html_document
---
### ELLIPTICAL COPULAS
```{r}
## 3.1 Elliptical copulas #####################################################

### Construction of elliptical distributions and sampling

## Stepwise generation of a sample from a bivariate t distribution
## via the (general) stochastic representation of elliptical distributions
n <- 1000 # sample size
d <- 2 # dimension
mu <- c(1, 3) # location vector
Sigma <- matrix(c(16, 4,
                   4, 2), ncol = 2, byrow = TRUE) # scale matrix
nu <- 3.5 # degrees of freedom
set.seed(271) # set a seed (for reproducibility)
R <- sqrt(d * rf(n, df1 = d, df2 = nu)) # sample R for a t_nu
A <- t(chol(Sigma)) # Cholesky factor
Z <- matrix(rnorm(n * d), ncol = d) # N_d(0,I_d)
S <- Z/sqrt(rowSums(Z^2)) # uniform distribution on unit sphere (= Z/||Z||)
X <- rep(mu, each = n) + R * t(A %*% t(S)) # X = mu + R A S
plot(S, xlab = quote(S[1]), ylab = quote(S[2]))
plot(t(A %*% t(S)), xlab = quote((AS)[1]), ylab = quote((AS)[2]))
xlim <- range(X[,1], X[,1] - mu[1])
ylim <- range(X[,2], X[,2] - mu[2])
plot(R * t(A %*% t(S)), xlab = quote(R(AS)[1]), ylab = quote(R(AS)[2]),
     xlim = xlim, ylim = ylim)
plot(X, xlab = quote(X[1]), ylab = quote(X[2]),
     xlim = xlim, ylim = ylim)

## 2-point distribution for R and corresponding X
R.2pt <- 1 + rbinom(n, size = 1, prob = 2/3) # prob. 1/3 to be 1, 2/3 to be 2
X.2pt <- rep(mu, each = n) + R.2pt * t(A %*% t(S)) # compute X
## Bounded distribution for R and corresponding X
pR <- function(q) pf(q^2/d, df1 = d, df2 = nu) # df of R for a t_nu
qR <- function(p) sqrt(d * qf(p, df1 = d, df2 = nu)) # quantile function
a <- 1; b <- 3 # [a, b]
R.bdd <- qR(pR(a) + runif(n) * (pR(b) - pR(a))) # sample R on [a,b]
X.bdd <- rep(mu, each = n) + R.bdd * t(A %*% t(S)) # compute X
plot(X.2pt, xlab = quote(X[1]), ylab = quote(X[2]))
plot(X.bdd, xlab = quote(X[1]), ylab = quote(X[2]))
```

### NORMAL COPULA
```{r}
library(copula)
nc <- normalCopula(iTau(normalCopula(), tau = 0.5))
set.seed(271)
U <- rCopula(1000, copula = nc) # sample from the normal copula
wireframe2(nc, FUN = dCopula, delta = 0.025) # density
contourplot2(nc, FUN = pCopula) # copula
contourplot2(nc, FUN = dCopula, n.grid = 42, cuts = 33, lwd = 1/2) # density
plot(U, xlab = quote(U[1]), ylab = quote(U[2])) # scatter plot
```

### t-COPULA
```{r}
### t copula

nu <- 4 # needs to be an integer here (only) because of pCopula()
tc <- tCopula(iTau(tCopula(df = nu), tau = 0.5), df = nu)
set.seed(271)
U <- rCopula(1000, copula = tc) # sample from the t copula
wireframe2(tc, FUN = dCopula, delta = 0.025) # density
contourplot2(tc, FUN = pCopula) # copula
contourplot2(tc, FUN = dCopula, n.grid = 42, cuts = 27) # density
plot(U, xlab = quote(U[1]), ylab = quote(U[2])) # scatter plot

## Setup
n <- 1000
d <- 5
nu <- 3.5
rho <- iTau(tCopula(df = nu), tau = 0.5)
P <- matrix(rho, nrow = d, ncol = d)
diag(P) <- 1
## Method 1: Directly using rmvt() from 'mvtnorm'
library(mvtnorm)
set.seed(271)
X <- rmvt(n, sigma = P, df = nu)
U <- pt(X, df = nu)
## Method 2: Reproducing rmvt()
set.seed(271)
eig <- eigen(P, symmetric = TRUE) # eigenvalue (instead of Cholesky) decomp.
A <- t(eig$vectors %*% (t(eig$vectors) * sqrt(eig$values)))
X.norm <- matrix(rnorm(n * d), nrow = n, byrow = TRUE) %*% A
X.t <- X.norm / sqrt(rchisq(n, nu) / nu)
U.rmvt <- pt(X.t, df = nu)
stopifnot(all.equal(U.rmvt, U))
## Method 3: rCopula()
set.seed(271)
U.cop <- rCopula(n, copula = tCopula(rho, dim = d, df = nu))
stopifnot(all.equal(U.cop, U.rmvt))

X.meta <- cbind(qt(U[,1], df = 2), qt(U[,2], df = 10))
plot(X,      xlab = quote(X[1]), ylab = quote(X[2]))
plot(X.meta, xlab = quote(X[1]), ylab = quote(X[2]))

```

### ARCHIMEDEAN COPULA
```{r}
### 3.2 Archimedean copulas ####################################################

### Graphs of selected Archimedean generators

copClayton@psi # generator of the Clayton family

t <- seq(0, 2, length.out = 257) # evaluation points
tau <- 0.5 # Kendall's tau
psi. <- cbind(Pi = exp(-t), # Pi generator
              C  = copClayton@psi(t, theta = iTau(claytonCopula(), tau)),
              F  = copFrank@psi  (t, theta = iTau(frankCopula(),   tau)),
              GH = copGumbel@psi (t, theta = iTau(gumbelCopula(),  tau)),
              J  = copJoe@psi    (t, theta = iTau(joeCopula(),     tau)))
plot(t, psi.[,1], type = "l", lwd = 2,
     xlim = range(t), ylim = range(psi.), col = 1, ylab = "",
     xlab = quote(psi(t)~"as a function of t"))
for(j in 2:ncol(psi.)) lines(t, psi.[,j], col = j, lwd = 2)
legend("topright", bty = "n", lty = 1, lwd = 2, col = 1:ncol(psi.),
       legend = c("Independence", "Clayton", "Frank",
                  "Gumbel-Hougaard", "Joe"))

```

### CLAYTON COPULA
```{r}
### Clayton copula

d <- 3
cc <- claytonCopula(4, dim = d) # theta = 4

set.seed(2013)
n <- 5
u <- matrix(runif(n * d), nrow = n) # random points in the unit hypercube
pCopula(u, copula = cc) # copula values at u

dCopula(u, copula = cc) # density values at u

set.seed(271)
U <- rCopula(1000, copula = cc)
splom2(U, cex = 0.3, col.mat = "black")
```

### GUMBELL COPULA

```{r}
### Gumbel-Hougaard copula

gc <- gumbelCopula(3) # theta = 3 (note the default dim = 2)

set.seed(1993)
U <- rCopula(1000, copula = gc)
plot(U, xlab = quote(U[1]), ylab = quote(U[2]))
wireframe2(gc, dCopula, delta = 0.025) # wireframe plot (density)
```

### FRANK COPULA

```{r}
### Frank copula

d <- 2 # dimension
theta <- -9 # copula parameter
fc <- frankCopula(theta, dim = d) # define a Frank copula

set.seed(2010)
n <- 5 # number of evaluation points
u <- matrix(runif(n * d), nrow = n) # n random points in [0,1]^d
pCopula(u, copula = fc) # copula values at u

dCopula(u, copula = fc) # density values at u

wireframe2(fc, FUN = pCopula, # wireframe plot (copula)
           draw.4.pCoplines = FALSE)
wireframe2(fc, FUN = dCopula, delta = 0.001) # wireframe plot (density)
contourplot2(fc, FUN = pCopula) # contour plot (copula)
contourplot2(fc, FUN = dCopula, n.grid = 72, # contour plot (density)
             lwd = 1/2)

set.seed(1946)
n <- 1000
U  <- rCopula(n, copula = fc)
U0 <- rCopula(n, copula = setTheta(fc, value = 0))
U9 <- rCopula(n, copula = setTheta(fc, value = 9))
plot(U,  xlab = quote(U[1]), ylab = quote(U[2]))
plot(U0, xlab = quote(U[1]), ylab = quote(U[2]))
plot(U9, xlab = quote(U[1]), ylab = quote(U[2]))

```

### DEPENDENCE MEASURE
```{r}
### 2.6.2 Rank correlation measures ############################################

### rho(), iRho(), tau() and iTau()

theta <- -0.7
stopifnot(all.equal(rho(normalCopula(theta)), 6 / pi * asin(theta / 2)))
stopifnot(all.equal(tau(normalCopula(theta)), 2 / pi * asin(theta)))
theta <- 2
stopifnot(all.equal(tau(claytonCopula(theta)), theta / (theta + 2)))
stopifnot(all.equal(tau(gumbelCopula(theta)), 1 - 1 / theta))

theta <- (0:8)/16
stopifnot(all.equal(iRho(normalCopula(), rho = 6/pi * asin(theta/2)), theta))
stopifnot(all.equal(iTau(normalCopula(), tau = 2/pi * asin(theta)),   theta))
theta <- 1:20
stopifnot(all.equal(iTau(claytonCopula(), theta / (theta + 2)), theta))
stopifnot(all.equal(iTau(gumbelCopula(),  1 - 1 / theta),       theta))

theta <- 3
iRho(claytonCopula(), rho = rho(claytonCopula(theta)))


### Estimating Spearman's rho and Kendall's tau

theta <- iRho(claytonCopula(), rho = 0.6) # true Spearman's rho = 0.6
set.seed(974)
U <- rCopula(1000, copula = claytonCopula(theta))
rho.def <- cor(apply(U, 2, rank))[1,2]      # Spearman's rho manually
rho.R   <- cor(U, method = "spearman")[1,2] # Spearman's rho from R
stopifnot(all.equal(rho.def, rho.R)) # the same
rho.R  # indeed close to 0.6

theta <- iTau(normalCopula(), tau = -0.5) # true Kendall's tau = -0.5
set.seed(974)
U <- rCopula(1000, copula = normalCopula(theta))
p.n <- 0
for(i in 1:(n-1)) # number of concordant pairs (obviously inefficient)
    for(j in (i+1):n)
        if(prod(apply(U[c(i,j),], 2, diff)) > 0) p.n <- p.n + 1
tau.def <- 4 * p.n / (n * (n - 1)) - 1   # Kendall's tau manually
tau.R <- cor(U, method = "kendall")[1,2] # Kendall's tau from R
stopifnot(all.equal(tau.def, tau.R)) # the same
tau.R # close to -0.5

```

### PARAMETERS ESTIMATION OF COPULA
### MAXIMUM LIKELIHOOD ESTIMATION METHOD (MLE)
```{r}
### Estimation of copula parameters via the MLE

## The "unknown" copula (a 2-dim. Clayton copula with parameter 3)
cc <- claytonCopula(3)
## The "unknown" distribution (N(0,1), Exp(1) margins)
mcc <- mvdc(cc, margins = c("norm", "exp"),
            paramMargins = list(list(mean = 0, sd = 1),
                                list(rate = 1)))
## Generate the "observed" sample
set.seed(712)
n <- 1000
X <- rMvdc(n, mvdc = mcc)
## The function fitMvdc() estimates all the parameters of the mvdc object
## mcc (whose parameter values are not used). Starting values need to be
## provided.
start <- c(mu0 = mean(X[,1]), sig0 = sd(X[,1]), lam0 = 1 / mean(X[,2]),
           th0 = 2)
(mle <- fitMvdc(X, mvdc = mcc, start = start))

summary(mle)

```

### INFERENCE FOR MARGINS (IFM)

```{r}
## Parametric pseudo-observations obtained from X by marginal MLE
U <- cbind(pnorm(X[,1], mean = mean(X[,1]),
                 sd = sqrt((n - 1) / n) * sd(X[,1])),
           pexp(X[,2], rate = 1 / mean(X[,2])))
ifme <- fitCopula(claytonCopula(), data = U, method = "ml")
summary(ifme)

optimMeth(claytonCopula(), method = "ml", dim = 2)
```

### METHOD OF MOMENTS BASED ON KENDALL'S TAU AND SPEARMAN RHO
```{r}
### Pseudo-observations of daily log-returns

data(rdj) # 'head(rdj)' for looking at the first six observations
splom2(rdj[,2:4], cex = 0.4, col.mat = adjustcolor("black", 0.5))

U <- pobs(rdj[,2:4])
splom2(U, cex = 0.4, col.mat = "black")


### Estimation of copula parameters via the method of moments based on Kendall's tau

## The "unknown" copula (a 2-dim. Gumbel-Hougaard copula with parameter 3)
gc <- gumbelCopula(3)
## The "unknown" distribution (N(0,1) margins)
mgc <- mvdc(gc, margins = c("norm", "norm"),
            paramMargins = list(list(mean = 0, sd = 1),
                                list(mean = 0, sd = 1)))
## Generate the "observed" sample
set.seed(49)
X <- rMvdc(1000, mvdc = mgc)
## The sample version of Kendall's tau
tau.n <- cor(X[,1], X[,2], method = "kendall")
## The corresponding copula parameter estimate
(itau <- iTau(gc, tau = tau.n))

stopifnot(all.equal(itau, 1 / (1 - tau.n))) # the same
## The same but with a standard error
summary(fitCopula(gumbelCopula(), data = pobs(X), method = "itau"))


### Estimation of copula parameters via the method of moments based on Spearman's rho

## The "unknown" copula (a 2-dim. normal copula with parameter 0.5)
nc <- normalCopula(0.5)
## Generate the "observed" sample
set.seed(314)
X <- rCopula(1000, nc)
## The sample estimate of Spearman's rho
rho.n <- cor(X[,1], X[,2], method = "spearman")
## The corresponding copula parameter estimate
(irho <- iRho(nc, rho = rho.n))

stopifnot(all.equal(irho, 2 * sin(pi * rho.n / 6))) # the same
## The same but with a standard error
summary(fitCopula(normalCopula(), data = pobs(X), method = "irho"))
```